# ArrayList vs. LinkedList
Во всех тестах элементами списков являются случайно сгенерированные строки длины, не превышающей 100.
В рассматриваемых выше тестах при помощи указанных операций происходило формирование соотв. списков заданного размера, таким образом,
эти графики представляют собой сравнение среднего времени работы данных операций. 

### Добавление элементов в конец (в среднем)
![Append chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/append-chart.png)

В случае, если планируется много вставок в конец, выбор ArrayList'a является предпочтительным. Для ArrayList'а гарантировано,
что время в ставки в конец в среднем будет составлять O(1). И хотя интуитивно понятно, что для LinkedList'a это время будет
O(1) в каждом конкретном случае, при вставке большого количества элементов подряд время, уходящее на создание каждого очередного звена,
оказывается критичным (что и демонстрирует график).
### Добавление элементов в начало (в среднем)
![IndexOf chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/addfirst-chart.png)

Явный фаворит в этом случае - LinkedList. Время вставки в начало у него O(1), в то время как у ArrayList'a оно *линейное*,
 ведь нам необходимо выполнить сдвиг всех элементов на одну позицию вправо. Быстрота вставки в начало - одно из основных 
 достоинств LinkedList'a.
### Вставка элементов в случайную позицию (в среднем)
![Add chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/add-chart.png)

Этот график наглядно демонстрирует, что если вам нужен random access, то вам однозначно не к LinkedList'у. С одной стороны, 
интуитивно кажется, чтобы вставить элемент в промежуточную позицию LinkedList'a, потребуется константное время, однако в случае, когда
вставка происходит по индексу, нам сперва необходимо перебрать все предыдущие элементы (или последующие, если индекс > size/2).
В случае же с ArrayList'ом, нам необходимо только сдвинуть последующие элементы вправо на одну позицию. И хотя в теории показатели
должны быть примерно равны, на практике ArrayList оказывается значительно быстрее: то ли дело в нативной функции System.arrayCopy(), 
то ли в том, что операция доступа по ссылке к следующему звену в LinkedList'e может оказаться слишком долгой в определенных 
случаях (да и время на создание каждого очередного звена, как уже было отмечено, никто не отменял).


### Удаление 10% случайных элементов по значению (в среднем)
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/remove-chart.png)

В данном тесте рассматривается удаление (по значению) 10% случайно выбранных элементов из листов указанного размера. В этом
случае такого явного преимущества за ArrayList'ом не наблюдается, поскольку основное его достоинство - доступ по индексу - 
не используется, а необходимость сдвигать часть элементов осталась. В свою очередь LinkedList'у теперь не нужно тратить
драгоценное время на создание звеньев. Использовать можно и то, и то без особых последствий.

- - - - 

#### Еще одно достоинство LinkedList'a
Все следующие графики демонстрируют выполнение операций вставки/удаления одного элемента при помощи итератора. Предполагается, что 
мы просматривали список в некотором направлении, и нам потребовалось вставить или удалить элемент в текущей позиции.
Скорость выполнения подобных операций - ещё одно достоинство LinkedList'a, ведь каждая из них может быть быполнена за O(1),
в то время как у ArrayList'a выполнение займёт O(n). Если нам нужно будет часто просматривать список, удаляя и вставляя
элементы в текущую позицию, выбор однозначно в пользу LinkedList'a.

### Вставка элемента в середину при помощи итератора
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/add-middle-iterator-chart.png)
### Вставка элемента в начало при помощи итератора
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/add-first-iterator-chart.png)
### Удаление элемента из середины при помощи итератора
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/remove-middle-iterator-chart.png)
### Удаление элемента из начала при помощи итератора
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/remove-first-iterator-chart.png)


- - - - 


# Hash[Set, Map] vs. LinkedHash[Set, Map] vs. Tree[Set, Map]
В данном разделе будут представлены графики времени выполнения в среднем операций добавления, поиска по ключу и удаления по
ключу. Сперва мы строим структуру данных указанного размера при помощи n операций добавления, затем в отдельном массиве случайно перемешиваем ключи и 
выполняем сперва поиск по ключу для каждого элемента, а затем перемешиваем ещё раз ключи и производим удаление всех элементов
по их ключам. В качестве ключей используются случайные строки с длиной не более 100 симв., а в качестве значений - Integer.
Сравнение операций совмещено для Set и Map, поскольку Set<KeyType> внутри себя использует Map<KeyType, Object>, то
есть представляет собой *по сути* Map соответствующего типа с некоторой константой в качестве значения для каждого ключа.

### Добавление элементов (в среднем)
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/SetsPerformance/add-chart.png)

![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/MapsPerformance/add-chart.png)

Как видим, по скорости доминируют Hash и LinkedHash структуры, поскольку для них гарантировано время добавления элемента
в среднем за O(1), в свою очередь у структур на основе красно-черных деревьев время выполнения представляет собой O(logN), где
N - число элементов. Несмотря на то, что графики практически сливаются для Hash и LinkedHash "коллекций", можно видеть, что
LinkedHash работает немного медленнее, это связано с затратами на поддержание внутреннего списка элементов в порядке их добавления.

### Поиск по ключу (в среднем)
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/SetsPerformance/contains-chart.png)

![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/MapsPerformance/contains-chart.png)

Для данной операции графики для Hash и LinkedHash "коллекций" сливаются полностью, поскольку различия в их реализации минимальные и
время выполнения в среднем всё так же O(1). Для Tree структур время выполнения снова логарифмическое от числа ключей.

### Удаление по ключу (в среднем)
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/SetsPerformance/remove-chart.png)

![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/MapsPerformance/remove-chart.png)

В данном случае повторяется ситуация аналогичная добавлению элементов, только отрыв Hash'a от LinkedHash'a уже немного более
значительный, объясняется это всё теми же затратами на удаление соответствующего элемента из внутреннего двусвязного списка,
где они хранятся в порядке добавления в структуру. Tree "коллекции" всё так же работают за логарифм от числа ключей.

#### Что выбрать
Таким образом, если в нашей задаче нам нужны исключительно описанные выше три операции и не требуется поддерживать некоторую
упорядоченность элементов, выбор однозначно должен быть за Hash структурами. Если требуется запоминать так же порядок добавления
элементов (для реализации какого-нибудь кэша, например), в таком случае нам подойдёт LinkedHash структура. И наконец, если нам
требуется поддерживать упорядоченность элементов в "коллекции" в соответствии с некоторой метрикой, то выбрать мы должны
Tree структуры. К слову, последнее и есть основное преимущество Tree "коллекций" перед Hash аналогами: мы можем получить
все n элементов в отсортированном порядке за O(n) в любой момент, просто перебрав все элементы в коллекции при помощи forEach(в
случае с Hash структурами нам необходимо будет сперва получить все элементы за O(n), а затем отсортировать их в отдельной структуре
за O(nlogn)).

Также следует отметить, что такого выбора может и не представиться, ведь далеко не для каждого класса можно найти подходящий
Comparator, в то время как хэш-функцию можно выбрать практически всегда.
