# ArrayList vs. LinkedList
Во всех тестах элементами списков являются случайно сгенерированные строки длины, не превышающей 100.
В рассматриваемых выше тестах при помощи указанных операций происходило формирование соотв. списков заданного размера, таким образом,
эти графики представляют собой сравнение среднего времени работы данных операций. 

### Добавление элементов в конец (в среднем)
![Append chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/append-chart.png)

В случае, если планируется много вставок в конец, выбор ArrayList'a является предпочтительным. Для ArrayList'а гарантировано,
что время в ставки в конец в среднем будет составлять O(1). И хотя интуитивно понятно, что для LinkedList'a это время будет
O(1) в каждом конкретном случае, при вставке большого количества элементов подряд время, уходящее на создание каждого очередного звена,
оказывается критичным (что и демонстрирует график).
### Добавление элементов в начало (в среднем)
![IndexOf chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/addfirst-chart.png)

Явный фаворит в этом случае - LinkedList. Время вставки в начало у него O(1), в то время как у ArrayList'a оно *линейное*,
 ведь нам необходимо выполнить сдвиг всех элементов на одну позицию вправо. Быстрота вставки в начало - одно из основных 
 достоинств LinkedList'a.
### Вставка элементов в случайную позицию (в среднем)
![Add chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/add-chart.png)

Этот график наглядно демонстрирует, что если вам нужен random access, то вам однозначно не к LinkedList'у. С одной стороны, 
интуитивно кажется, чтобы вставить элемент в промежуточную позицию LinkedList'a, потребуется константное время, однако в случае, когда
вставка происходит по индексу, нам сперва необходимо перебрать все предыдущие элементы (или последующие, если индекс > size/2).
В случае же с ArrayList'ом, нам необходимо только сдвинуть последующие элементы вправо на одну позицию. И хотя в теории показатели
должны быть примерно равны, на практике ArrayList оказывается значительно быстрее: то ли дело в нативной функции System.arrayCopy(), 
то ли в том, что операция доступа по ссылке к следующему звену в LinkedList'e может оказаться слишком долгой в определенных 
случаях (да и время на создание каждого очередного звена, как уже было отмечено, никто не отменял).


### Удаление 10% случайных элементов по значению (в среднем)
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/remove-chart.png)

В данном тесте рассматривается удаление (по значению) 10% случайно выбранных элементов из листов указанного размера. В этом
случае такого явного преимущества за ArrayList'ом не наблюдается, поскольку основное его достоинство - доступ по индексу - 
не используется, а необходимость сдвигать часть элементов осталась. В свою очередь LinkedList'у теперь не нужно тратить
драгоценное время на создание звеньев. Использовать можно и то, и то без особых последствий.

- - - - 

#### Еще одно достоинство LinkedList'a
Все следующие графики демонстрируют выполнение операций вставки/удаления одного элемента при помощи итератора. Предполагается, что 
мы просматривали список в некотором направлении, и нам потребовалось вставить или удалить элемент в текущей позиции.
Скорость выполнения подобных операций - ещё одно достоинство LinkedList'a, ведь каждая из них может быть быполнена за O(1),
в то время как у ArrayList'a выполнение займёт O(n). Если нам нужно будет часто просматривать список, удаляя и вставляя
элементы в текущую позицию, выбор однозначно в пользу LinkedList'a.

### Вставка элемента в середину при помощи итератора
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/add-middle-iterator-chart.png)
### Вставка элемента в начало при помощи итератора
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/add-first-iterator-chart.png)
### Удаление элемента из середины при помощи итератора
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/remove-middle-iterator-chart.png)
### Удаление элемента из начала при помощи итератора
![Remove chart](https://raw.githubusercontent.com/alitsov/netcracker-java-practice/master/src/resources/ListsPerformance/remove-first-iterator-chart.png)

